{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Minotaor Work in progress Minotaor is an a mino acid sequence anno ta t or for quickly identifying common protein tags and linkers in an ORF. Additionally, it can flag peptide sequences or patterns that are known to cause problems during translation. It uses Biopython. Install pip install minotaor Usage import minotaor from Bio.Seq import Seq from Bio.SeqRecord import SeqRecord protein = Seq ( \"SYYHHHHHHDYDIPTTENLYFQG*EDINBURGHGENQMEFQUNDRY*\" ) protein_record = SeqRecord ( protein , id = \"example\" , annotations = { \"molecule_type\" : \"protein\" }) protein_record = minotaor . annotate_record ( protein_record ) # Define a custom translator: from dna_features_viewer import BiopythonTranslator class MinotaorTranslator ( BiopythonTranslator ): \"\"\"Custom translator. Color warnings in red, CDS in default color, all other features in blue. \"\"\" def compute_feature_color ( self , feature ): if feature . type == \"warning\" : return \"red\" elif feature . type == \"CDS\" : return \"#7245dc\" else : return \"blue\" def compute_feature_label ( self , feature ): return feature . id graphic_record = MinotaorTranslator () . translate_record ( protein_record ) ax , _ = graphic_record . plot ( figure_width = 10 , strand_in_label_threshold = 7 ) graphic_record . plot_sequence ( ax ) Versioning Minotaor uses the semantic versioning scheme. License = MIT Minotaor is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Minotaor was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"Home"},{"location":"#minotaor","text":"Work in progress Minotaor is an a mino acid sequence anno ta t or for quickly identifying common protein tags and linkers in an ORF. Additionally, it can flag peptide sequences or patterns that are known to cause problems during translation. It uses Biopython.","title":"Minotaor"},{"location":"#install","text":"pip install minotaor","title":"Install"},{"location":"#usage","text":"import minotaor from Bio.Seq import Seq from Bio.SeqRecord import SeqRecord protein = Seq ( \"SYYHHHHHHDYDIPTTENLYFQG*EDINBURGHGENQMEFQUNDRY*\" ) protein_record = SeqRecord ( protein , id = \"example\" , annotations = { \"molecule_type\" : \"protein\" }) protein_record = minotaor . annotate_record ( protein_record ) # Define a custom translator: from dna_features_viewer import BiopythonTranslator class MinotaorTranslator ( BiopythonTranslator ): \"\"\"Custom translator. Color warnings in red, CDS in default color, all other features in blue. \"\"\" def compute_feature_color ( self , feature ): if feature . type == \"warning\" : return \"red\" elif feature . type == \"CDS\" : return \"#7245dc\" else : return \"blue\" def compute_feature_label ( self , feature ): return feature . id graphic_record = MinotaorTranslator () . translate_record ( protein_record ) ax , _ = graphic_record . plot ( figure_width = 10 , strand_in_label_threshold = 7 ) graphic_record . plot_sequence ( ax )","title":"Usage"},{"location":"#versioning","text":"Minotaor uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-mit","text":"Minotaor is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Minotaor was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"License = MIT"},{"location":"reference/minotaor/","text":"Module minotaor View Source from .minotaor import ( annotate_record , create_and_annotate_record , convert_prosite_to_regex , seq_dataset , ) from .version import __version__ Sub-modules minotaor.minotaor minotaor.version","title":"Index"},{"location":"reference/minotaor/#module-minotaor","text":"View Source from .minotaor import ( annotate_record , create_and_annotate_record , convert_prosite_to_regex , seq_dataset , ) from .version import __version__","title":"Module minotaor"},{"location":"reference/minotaor/#sub-modules","text":"minotaor.minotaor minotaor.version","title":"Sub-modules"},{"location":"reference/minotaor/minotaor/","text":"Module minotaor.minotaor View Source import os import re import pandas from Bio . Seq import Seq from Bio . SeqFeature import SeqFeature , FeatureLocation from Bio . SeqRecord import SeqRecord DATA_DIR = os . path . join ( os . path . dirname ( os . path . realpath ( __ file__ )), \"data\" ) seq_dataset = pandas . read_csv ( os . path . join ( DATA_DIR , \"seq.csv\" )) def annotate_record ( seqrecord , seq_dataset = seq_dataset ) : \"\"\"Annotate a record with a reference sequence dataset. **Parameters** **seqrecord** > SeqRecord to annotate. **seq_dataset** > A minotaor sequence dataset (`pandas.DataFrame`). \"\"\" # FLAG NO START : M if str ( seqrecord . seq )[ 0 ] ! = \"M\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( 0 , 1 ), type= \"warning\" , id= \"no start codon\" ) ) # FLAG NO END : * if str ( seqrecord . seq )[ - 1 ] ! = \"*\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( len ( seqrecord ) - 1 , len ( seqrecord )), type= \"warning\" , id= \"not a stop codon\" , ) ) # FLAG STOP CODONS : * stop_positions = [ i for i , letter in enumerate ( str ( seqrecord . seq )) if letter == \"*\" ] for position in stop_positions: seqrecord . features . append ( SeqFeature ( FeatureLocation ( position , position + 1 ), type= \"warning\" , id= \"STOP\" ) ) # ANNOTATE SEQUENCES sequences = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"seq\" ][ \"sequence\" ]. to_list () names = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"seq\" ][ \"name\" ]. to_list () for index , sequence in enumerate ( sequences ) : len_sequence = len ( sequence ) name = names [ index ] matches = [ m . start () for m in re . finditer ( re . escape ( sequence ), str ( seqrecord . seq )) ] for match in matches : seqrecord . features . append ( SeqFeature ( FeatureLocation ( match , ( match + len_sequence )), type= \"CDS\" , id = name ) ) # ANNOTATE PATTERNS patterns = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"pattern\" ][ \"sequence\" ]. to_list () names = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"pattern\" ][ \"name\" ]. to_list () for index , pattern in enumerate ( patterns ) : name = names [ index ] matches = { m . start () : m . end () for m in re . finditer ( pattern , str ( seqrecord . seq ))} for start , end in matches . items () : seqrecord . features . append ( SeqFeature ( FeatureLocation ( start , end ), type= \"CDS\" , id = name ) ) return seqrecord def create_and_annotate_record ( sequence , seq_dataset = seq_dataset ) : \"\"\"Create a SeqRecord from an amino acid sequence string. **Parameters** **sequence** > Sequence (`str`). \"\"\" if seq_dataset is None : seq_dataset = seq_dataset protein = Seq ( sequence ) protein_record = SeqRecord ( protein , id= \"example\" , annotations= { \"molecule_type\" : \"protein\" } ) protein_record = annotate_record ( protein_record ) return protein_record def convert_prosite_to_regex ( prosite_string ) : \"\"\"Convert a PROSITE motif string to a regex string. **Parameters** **prosite_string** > The PROSITE string (`str`). \"\"\" # Implemented with a hack : by replacing characters , instead of using a lexer . # See https : // prosite . expasy . org / prosuser . html#conv_pa for definition . # Remove period that ends the pattern : if prosite_string [ - 1 ] == \".\" : prosite_string = prosite_string [:- 1 ] else : raise ValueError ( \"Invalid format: a period ('.') must end the pattern\" ) # N - and C - terminal restrictions : if \"<\" in prosite_string: N_terminal = True prosite_string = prosite_string . replace ( \"<\" , \"\" ) else : N_terminal = False if \">\" in prosite_string: if prosite_string [ - 1 ] ! = \">\" : raise Exception ( \"'>' inside square brackets is not supported yet\" ) C_terminal = True prosite_string = prosite_string . replace ( \">\" , \"\" ) else : C_terminal = False tokens = prosite_string . split ( \"-\" ) regex_tokens = [] for token in tokens : # Convert 'x' to regex : any amino acid , but don ' t match stop codons . token = token . replace ( \"x\" , \" [ ^\\\\* ] \") # Replace braces for exceptions. if token[0] == \" { \": token = token.replace(\" { \", \" [ ^ \") token = token.replace(\" } \", \" ] \") # Replace for repetition. Must come after exception replacement. token = token.replace(\" ( \", \" { \") token = token.replace(\" ) \", \" } \") regex_tokens += [token] regex = \"\".join(regex_tokens) if N_terminal: regex = \" ^ \" + regex if C_terminal: regex += \" $\" return regex Variables DATA_DIR seq_dataset Functions annotate_record def annotate_record ( seqrecord , seq_dataset = id ... reference 0 6 xHis ... NaN 1 TEV_site ... NaN 2 ALFA_tag ... NaN 3 AviTag ... NaN 4 C_tag ... NaN .. ... ... ... 86 Furin_site_polyarginine ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 87 Cathepsin_B_site ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 88 FLAG_tag_pattern ... NaN 89 Polyarginine_tag_pattern ... NaN 90 His_tag_pattern ... NaN [ 91 rows x 9 columns ] ) Annotate a record with a reference sequence dataset. Parameters seqrecord SeqRecord to annotate. seq_dataset A minotaor sequence dataset ( pandas.DataFrame ). View Source def annotate_record ( seqrecord , seq_dataset = seq_dataset ) : \"\"\"Annotate a record with a reference sequence dataset. **Parameters** **seqrecord** > SeqRecord to annotate. **seq_dataset** > A minotaor sequence dataset (`pandas.DataFrame`). \"\"\" # FLAG NO START : M if str ( seqrecord . seq ) [ 0 ] != \"M\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( 0 , 1 ), type = \"warning\" , id = \"no start codon\" ) ) # FLAG NO END : * if str ( seqrecord . seq ) [ -1 ] != \"*\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( len ( seqrecord ) - 1 , len ( seqrecord )), type = \"warning\" , id = \"not a stop codon\" , ) ) # FLAG STOP CODONS : * stop_positions = [ i for i, letter in enumerate(str(seqrecord.seq)) if letter == \"*\" ] for position in stop_positions : seqrecord . features . append ( SeqFeature ( FeatureLocation ( position , position + 1 ), type = \"warning\" , id = \"STOP\" ) ) # ANNOTATE SEQUENCES sequences = seq_dataset . loc [ seq_dataset[\"type\" ] == \"seq\" ] [ \"sequence\" ] . to_list () names = seq_dataset . loc [ seq_dataset[\"type\" ] == \"seq\" ] [ \"name\" ] . to_list () for index , sequence in enumerate ( sequences ) : len_sequence = len ( sequence ) name = names [ index ] matches = [ m.start() for m in re.finditer(re.escape(sequence), str(seqrecord.seq)) ] for match in matches : seqrecord . features . append ( SeqFeature ( FeatureLocation ( match , ( match + len_sequence )), type = \"CDS\" , id = name ) ) # ANNOTATE PATTERNS patterns = seq_dataset . loc [ seq_dataset[\"type\" ] == \"pattern\" ] [ \"sequence\" ] . to_list () names = seq_dataset . loc [ seq_dataset[\"type\" ] == \"pattern\" ] [ \"name\" ] . to_list () for index , pattern in enumerate ( patterns ) : name = names [ index ] matches = { m . start () : m . end () for m in re . finditer ( pattern , str ( seqrecord . seq )) } for start , end in matches . items () : seqrecord . features . append ( SeqFeature ( FeatureLocation ( start , end ), type = \"CDS\" , id = name ) ) return seqrecord convert_prosite_to_regex def convert_prosite_to_regex ( prosite_string ) Convert a PROSITE motif string to a regex string. Parameters prosite_string The PROSITE string ( str ). View Source def convert_prosite_to_regex ( prosite_string ) : \"\"\"Convert a PROSITE motif string to a regex string. **Parameters** **prosite_string** > The PROSITE string (`str`). \"\"\" # Implemented with a hack : by replacing characters , instead of using a lexer . # See https : // prosite . expasy . org / prosuser . html#conv_pa for definition . # Remove period that ends the pattern : if prosite_string [ - 1 ] == \".\" : prosite_string = prosite_string [:- 1 ] else : raise ValueError ( \"Invalid format: a period ('.') must end the pattern\" ) # N - and C - terminal restrictions : if \"<\" in prosite_string: N_terminal = True prosite_string = prosite_string . replace ( \"<\" , \"\" ) else : N_terminal = False if \">\" in prosite_string: if prosite_string [ - 1 ] ! = \">\" : raise Exception ( \"'>' inside square brackets is not supported yet\" ) C_terminal = True prosite_string = prosite_string . replace ( \">\" , \"\" ) else : C_terminal = False tokens = prosite_string . split ( \"-\" ) regex_tokens = [] for token in tokens : # Convert 'x' to regex : any amino acid , but don ' t match stop codons . token = token . replace ( \"x\" , \" [ ^\\\\* ] \") # Replace braces for exceptions. if token[0] == \" { \": token = token.replace(\" { \", \" [ ^ \") token = token.replace(\" } \", \" ] \") # Replace for repetition. Must come after exception replacement. token = token.replace(\" ( \", \" { \") token = token.replace(\" ) \", \" } \") regex_tokens += [token] regex = \"\".join(regex_tokens) if N_terminal: regex = \" ^ \" + regex if C_terminal: regex += \" $\" return regex create_and_annotate_record def create_and_annotate_record ( sequence , seq_dataset = id ... reference 0 6 xHis ... NaN 1 TEV_site ... NaN 2 ALFA_tag ... NaN 3 AviTag ... NaN 4 C_tag ... NaN .. ... ... ... 86 Furin_site_polyarginine ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 87 Cathepsin_B_site ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 88 FLAG_tag_pattern ... NaN 89 Polyarginine_tag_pattern ... NaN 90 His_tag_pattern ... NaN [ 91 rows x 9 columns ] ) Create a SeqRecord from an amino acid sequence string. Parameters sequence Sequence ( str ). View Source def create_and_annotate_record ( sequence , seq_dataset = seq_dataset ) : \" \"\" Create a SeqRecord from an amino acid sequence string. **Parameters** **sequence** > Sequence (`str`). \"\" \" if seq_dataset is None : seq_dataset = seq_dataset protein = Seq ( sequence ) protein_record = SeqRecord ( protein , id = \"example\" , annotations = { \"molecule_type\" : \"protein\" } ) protein_record = annotate_record ( protein_record ) return protein_record","title":"Minotaor"},{"location":"reference/minotaor/minotaor/#module-minotaorminotaor","text":"View Source import os import re import pandas from Bio . Seq import Seq from Bio . SeqFeature import SeqFeature , FeatureLocation from Bio . SeqRecord import SeqRecord DATA_DIR = os . path . join ( os . path . dirname ( os . path . realpath ( __ file__ )), \"data\" ) seq_dataset = pandas . read_csv ( os . path . join ( DATA_DIR , \"seq.csv\" )) def annotate_record ( seqrecord , seq_dataset = seq_dataset ) : \"\"\"Annotate a record with a reference sequence dataset. **Parameters** **seqrecord** > SeqRecord to annotate. **seq_dataset** > A minotaor sequence dataset (`pandas.DataFrame`). \"\"\" # FLAG NO START : M if str ( seqrecord . seq )[ 0 ] ! = \"M\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( 0 , 1 ), type= \"warning\" , id= \"no start codon\" ) ) # FLAG NO END : * if str ( seqrecord . seq )[ - 1 ] ! = \"*\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( len ( seqrecord ) - 1 , len ( seqrecord )), type= \"warning\" , id= \"not a stop codon\" , ) ) # FLAG STOP CODONS : * stop_positions = [ i for i , letter in enumerate ( str ( seqrecord . seq )) if letter == \"*\" ] for position in stop_positions: seqrecord . features . append ( SeqFeature ( FeatureLocation ( position , position + 1 ), type= \"warning\" , id= \"STOP\" ) ) # ANNOTATE SEQUENCES sequences = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"seq\" ][ \"sequence\" ]. to_list () names = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"seq\" ][ \"name\" ]. to_list () for index , sequence in enumerate ( sequences ) : len_sequence = len ( sequence ) name = names [ index ] matches = [ m . start () for m in re . finditer ( re . escape ( sequence ), str ( seqrecord . seq )) ] for match in matches : seqrecord . features . append ( SeqFeature ( FeatureLocation ( match , ( match + len_sequence )), type= \"CDS\" , id = name ) ) # ANNOTATE PATTERNS patterns = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"pattern\" ][ \"sequence\" ]. to_list () names = seq_dataset . loc [ seq_dataset [ \"type\" ] == \"pattern\" ][ \"name\" ]. to_list () for index , pattern in enumerate ( patterns ) : name = names [ index ] matches = { m . start () : m . end () for m in re . finditer ( pattern , str ( seqrecord . seq ))} for start , end in matches . items () : seqrecord . features . append ( SeqFeature ( FeatureLocation ( start , end ), type= \"CDS\" , id = name ) ) return seqrecord def create_and_annotate_record ( sequence , seq_dataset = seq_dataset ) : \"\"\"Create a SeqRecord from an amino acid sequence string. **Parameters** **sequence** > Sequence (`str`). \"\"\" if seq_dataset is None : seq_dataset = seq_dataset protein = Seq ( sequence ) protein_record = SeqRecord ( protein , id= \"example\" , annotations= { \"molecule_type\" : \"protein\" } ) protein_record = annotate_record ( protein_record ) return protein_record def convert_prosite_to_regex ( prosite_string ) : \"\"\"Convert a PROSITE motif string to a regex string. **Parameters** **prosite_string** > The PROSITE string (`str`). \"\"\" # Implemented with a hack : by replacing characters , instead of using a lexer . # See https : // prosite . expasy . org / prosuser . html#conv_pa for definition . # Remove period that ends the pattern : if prosite_string [ - 1 ] == \".\" : prosite_string = prosite_string [:- 1 ] else : raise ValueError ( \"Invalid format: a period ('.') must end the pattern\" ) # N - and C - terminal restrictions : if \"<\" in prosite_string: N_terminal = True prosite_string = prosite_string . replace ( \"<\" , \"\" ) else : N_terminal = False if \">\" in prosite_string: if prosite_string [ - 1 ] ! = \">\" : raise Exception ( \"'>' inside square brackets is not supported yet\" ) C_terminal = True prosite_string = prosite_string . replace ( \">\" , \"\" ) else : C_terminal = False tokens = prosite_string . split ( \"-\" ) regex_tokens = [] for token in tokens : # Convert 'x' to regex : any amino acid , but don ' t match stop codons . token = token . replace ( \"x\" , \" [ ^\\\\* ] \") # Replace braces for exceptions. if token[0] == \" { \": token = token.replace(\" { \", \" [ ^ \") token = token.replace(\" } \", \" ] \") # Replace for repetition. Must come after exception replacement. token = token.replace(\" ( \", \" { \") token = token.replace(\" ) \", \" } \") regex_tokens += [token] regex = \"\".join(regex_tokens) if N_terminal: regex = \" ^ \" + regex if C_terminal: regex += \" $\" return regex","title":"Module minotaor.minotaor"},{"location":"reference/minotaor/minotaor/#variables","text":"DATA_DIR seq_dataset","title":"Variables"},{"location":"reference/minotaor/minotaor/#functions","text":"","title":"Functions"},{"location":"reference/minotaor/minotaor/#annotate_record","text":"def annotate_record ( seqrecord , seq_dataset = id ... reference 0 6 xHis ... NaN 1 TEV_site ... NaN 2 ALFA_tag ... NaN 3 AviTag ... NaN 4 C_tag ... NaN .. ... ... ... 86 Furin_site_polyarginine ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 87 Cathepsin_B_site ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 88 FLAG_tag_pattern ... NaN 89 Polyarginine_tag_pattern ... NaN 90 His_tag_pattern ... NaN [ 91 rows x 9 columns ] ) Annotate a record with a reference sequence dataset. Parameters seqrecord SeqRecord to annotate. seq_dataset A minotaor sequence dataset ( pandas.DataFrame ). View Source def annotate_record ( seqrecord , seq_dataset = seq_dataset ) : \"\"\"Annotate a record with a reference sequence dataset. **Parameters** **seqrecord** > SeqRecord to annotate. **seq_dataset** > A minotaor sequence dataset (`pandas.DataFrame`). \"\"\" # FLAG NO START : M if str ( seqrecord . seq ) [ 0 ] != \"M\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( 0 , 1 ), type = \"warning\" , id = \"no start codon\" ) ) # FLAG NO END : * if str ( seqrecord . seq ) [ -1 ] != \"*\" : seqrecord . features . append ( SeqFeature ( FeatureLocation ( len ( seqrecord ) - 1 , len ( seqrecord )), type = \"warning\" , id = \"not a stop codon\" , ) ) # FLAG STOP CODONS : * stop_positions = [ i for i, letter in enumerate(str(seqrecord.seq)) if letter == \"*\" ] for position in stop_positions : seqrecord . features . append ( SeqFeature ( FeatureLocation ( position , position + 1 ), type = \"warning\" , id = \"STOP\" ) ) # ANNOTATE SEQUENCES sequences = seq_dataset . loc [ seq_dataset[\"type\" ] == \"seq\" ] [ \"sequence\" ] . to_list () names = seq_dataset . loc [ seq_dataset[\"type\" ] == \"seq\" ] [ \"name\" ] . to_list () for index , sequence in enumerate ( sequences ) : len_sequence = len ( sequence ) name = names [ index ] matches = [ m.start() for m in re.finditer(re.escape(sequence), str(seqrecord.seq)) ] for match in matches : seqrecord . features . append ( SeqFeature ( FeatureLocation ( match , ( match + len_sequence )), type = \"CDS\" , id = name ) ) # ANNOTATE PATTERNS patterns = seq_dataset . loc [ seq_dataset[\"type\" ] == \"pattern\" ] [ \"sequence\" ] . to_list () names = seq_dataset . loc [ seq_dataset[\"type\" ] == \"pattern\" ] [ \"name\" ] . to_list () for index , pattern in enumerate ( patterns ) : name = names [ index ] matches = { m . start () : m . end () for m in re . finditer ( pattern , str ( seqrecord . seq )) } for start , end in matches . items () : seqrecord . features . append ( SeqFeature ( FeatureLocation ( start , end ), type = \"CDS\" , id = name ) ) return seqrecord","title":"annotate_record"},{"location":"reference/minotaor/minotaor/#convert_prosite_to_regex","text":"def convert_prosite_to_regex ( prosite_string ) Convert a PROSITE motif string to a regex string. Parameters prosite_string The PROSITE string ( str ). View Source def convert_prosite_to_regex ( prosite_string ) : \"\"\"Convert a PROSITE motif string to a regex string. **Parameters** **prosite_string** > The PROSITE string (`str`). \"\"\" # Implemented with a hack : by replacing characters , instead of using a lexer . # See https : // prosite . expasy . org / prosuser . html#conv_pa for definition . # Remove period that ends the pattern : if prosite_string [ - 1 ] == \".\" : prosite_string = prosite_string [:- 1 ] else : raise ValueError ( \"Invalid format: a period ('.') must end the pattern\" ) # N - and C - terminal restrictions : if \"<\" in prosite_string: N_terminal = True prosite_string = prosite_string . replace ( \"<\" , \"\" ) else : N_terminal = False if \">\" in prosite_string: if prosite_string [ - 1 ] ! = \">\" : raise Exception ( \"'>' inside square brackets is not supported yet\" ) C_terminal = True prosite_string = prosite_string . replace ( \">\" , \"\" ) else : C_terminal = False tokens = prosite_string . split ( \"-\" ) regex_tokens = [] for token in tokens : # Convert 'x' to regex : any amino acid , but don ' t match stop codons . token = token . replace ( \"x\" , \" [ ^\\\\* ] \") # Replace braces for exceptions. if token[0] == \" { \": token = token.replace(\" { \", \" [ ^ \") token = token.replace(\" } \", \" ] \") # Replace for repetition. Must come after exception replacement. token = token.replace(\" ( \", \" { \") token = token.replace(\" ) \", \" } \") regex_tokens += [token] regex = \"\".join(regex_tokens) if N_terminal: regex = \" ^ \" + regex if C_terminal: regex += \" $\" return regex","title":"convert_prosite_to_regex"},{"location":"reference/minotaor/minotaor/#create_and_annotate_record","text":"def create_and_annotate_record ( sequence , seq_dataset = id ... reference 0 6 xHis ... NaN 1 TEV_site ... NaN 2 ALFA_tag ... NaN 3 AviTag ... NaN 4 C_tag ... NaN .. ... ... ... 86 Furin_site_polyarginine ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 87 Cathepsin_B_site ... Chen et al . ( 2013 ), Adv Drug Deliv Rev 65 ( 10 ): ... 88 FLAG_tag_pattern ... NaN 89 Polyarginine_tag_pattern ... NaN 90 His_tag_pattern ... NaN [ 91 rows x 9 columns ] ) Create a SeqRecord from an amino acid sequence string. Parameters sequence Sequence ( str ). View Source def create_and_annotate_record ( sequence , seq_dataset = seq_dataset ) : \" \"\" Create a SeqRecord from an amino acid sequence string. **Parameters** **sequence** > Sequence (`str`). \"\" \" if seq_dataset is None : seq_dataset = seq_dataset protein = Seq ( sequence ) protein_record = SeqRecord ( protein , id = \"example\" , annotations = { \"molecule_type\" : \"protein\" } ) protein_record = annotate_record ( protein_record ) return protein_record","title":"create_and_annotate_record"},{"location":"reference/minotaor/version/","text":"Module minotaor.version View Source __version__ = \"0.1.0\"","title":"Version"},{"location":"reference/minotaor/version/#module-minotaorversion","text":"View Source __version__ = \"0.1.0\"","title":"Module minotaor.version"}]}